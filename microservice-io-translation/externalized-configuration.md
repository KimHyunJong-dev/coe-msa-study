# 패턴 : 외부화된 환경설정

## 상황

어플리케이션은 일반적으로 다양한 인프라와 써드파티 서비스를 사용한다. 인프라 서비스는 서비스 등록, 메시지 브로커, 데이터베이스 서버 등을 예로 들 수 있다. 써드파티 서비스는 결제, 이메일, 메시징 서비스 등을 예로 들 수 있다.

## 문제점

수정없이 다양한 환경에서 서비스을 수행하도록 할 수 있을까?

## Forces

* 서비스는 외부/써드파티 서비스에 연결하는 방법 등에 대한 환경설정 자료를 제공받아야한다. 예를 들어, 데이터베이스 접속 정보 등이 있다.
* 서비스는 개발, 테스트, QA, 스테이징, 프로덕션 등 다양한 환경에서 수정 및 리빌드 없이 실행되어야 한다.
* 다양한 환경에 대한 외부/써드파티 서비스의 인스턴스 또한 다르게 관리되어야 한다. 예를 들어, QA와 운영 환경의 데이터베이스는 구분되어야한다. 테스트와 운영 환경의 신용카드 결제 계정 관리도 구분되어야한다.

## 해결책

데이터베이스 관련 설정, 네트워크 접속 정보 등 모든 어플리케이션의 환경설정 정보를 어플리케이션의 외부에서 관리한다. 서비스 인스턴스 구동시, 외부 레파지토리에서 그러한 환경설정 정보를 읽어오도록 한다.

## 예제

외부화된 환경설정을 이용하여 스프링 부트 어플리케이션은 운영 체제의 환경 변수, 환경 변수 파일, 커맨드라인 인자 등 다양한 소스에서 값을 참조한다. 이 값은 스프링 어플리케이션 컨텍스트 내에서 사용 가능하다.

아래의 [마이크로서비스 예제 어플리케이션](externalized-configuration.md)의 **RegistrationServiceProxy** 는 **user\_registration\_url** 변수를 읽어와 사용하는 Scala 코드 예제이다.

```java
@Component
class RegistrationServiceProxy @Autowired()(restTemplate: RestTemplate) extends RegistrationService {

  @Value("${user_registration_url}")
  var userRegistrationUrl: String = _
```

아래 **docker-compose.yml** 파일은 환경 변수의 값들을 제공하는 예제이다.

```yaml
web:
  image: sb_web
  ports:
    - "8080:8080"
  links:
    - eureka
  environment:
    USER_REGISTRATION_URL: http://REGISTRATION-SERVICE/user
```

**REGISTRATION-SERVICE** 는 서비스의 논리적 이름이며 클라이언트측 탐지에 사용된다.

## 결론

장점

* 어플리케이션이 수정 및 컴파일 없이 다양한 환경에서 작동한다.

문제점

* 어플리케이션이 환경설정을 참조하여 배포될 때 기대했던 것과 일치하는지 어떻게 알 수 있을까?

## 관련 패턴

* 서비스 탐지 패턴\(서버측 서비스 탐지, 클라이언트측 서비스 탐지\)을 통해 특정 서비스가 다른 어플리케이션 서비스의 네트워크 상 위치를 참조하는 방법 관련된 문제를 해결할 수 있다.

