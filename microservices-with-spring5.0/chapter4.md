# 4장 마이크로서비스 개념 적용

## 패턴 및 설계 상의 일반적인 의사 결정

MSA 는 만병통치약이 아니다. 치밀하게 분석하여 올바른 설계결정이 필요하다. 따라서 아래와 같은 고려사항이 필요하다.

\[고려사항\]

1. 적절한 마이크로 경계설정
   * DDD 
     * Bounded Context 
     * Domain - Subdomain - entity
     * aggregate
   * 방법
     * 자율적인 기능 : 단독 서비스 가능한 UTIL 혹은 서비스 단위
     * 배포 단위의 크기 : 배포 단위의 크기를 관리 할 수 있는 수주으로 유지
     * 분리하기에 가장 적한한 기능 또는 서브도메인 : 기준 - 자원 소모량, 소유 비용, 비즈니스 효용성, 유연성 측면
     * 폴리글랏 아키텍처 
     * 선택적 확장: 확장에 대한 요구사항을 기준으로 마이크로 서비스의 경계 결정 
     * 작고 애자일한 팀 
     * 단일 책임 : 하나의 책임 != 하나의 서비스, 종단점 --&gt; 하나의 책임 : 하나의 비즈니스 범위 또는 하나의 기술 범위 

       > CQRS 대부분의 데이터베이스 트랜잭션은 데이터베이스로부터 데이터를 읽어들여 화면에 뿌려주는 것이다. 이때, 데이터베이스에서 데이터를 읽는 시점과 화면에 렌더링을 하는 시점은 반드시 차이가 생기기 마련이며, 렌더링하는 데이터는 이미 실제 데이터와는 차이가 생기게 마련이다. CQRS 패턴은 이점을 인정하고 여기서부터 시작한다. 따라서, 굳이 하나의 데이터베이스 안에서 CRUD의 R에 해당하는 기능과 나머지 CUD 기능을 공존시키는 것이 의미가 없다는 것이 이 패턴의 핵심. 어차피 R의 결과물은 정도의 차이는 있을지언정 실제 데이터와 다르니 캐쉬로 돌려서 더욱 빠르게 사용자들이 읽어들일 수 있도록 하고, CUD는 메시지 큐를 통해 실제 데이터를 변경시키고, 그 변경이 일어나는 시점에 이벤트를 발생시켜서 캐쉬를 업데이트하는 방식으로 진행하자는 것. -- 참고: [CQRS Starting Page](https://abdullin.com/post/when-not-to-use-cqrs/)

     * 복제 가능성과 변경 가능성
     * 결합과 응집 : 트랜젝셔 범위가 하나의 마이크로서비스의 범위를 넘지 안도록 한다. 
     * 마이크로서비스를 하나의 제품으로 생각하기 : Bounded Context를 하나의 제품으로 생각하는 것 
2. 통신 방식의 설계
   * 동기 방식 통신 :
     * 장점: \(1\) Application stateless \(2\) 인스턴스 트래픽 분산 \(3\) 공유 메세지 서버가 필요 없음\(관리상 이점\) \(4\) 일관성 \(5\) 실시간성
     * 단점 : \(1\) 응답을 기다려야 한다. --&gt; 이후에 많은 부작용 발생 \(2\) 의존관계 \(3\) 서비스 체인....문제 발생시 연쇄적으로 문제 발생
   * 비동기 방식 통신
     * 장점:     

         \(1\) 서비스가 독립적         

         \(2\) Thread를 내부에서 재생산, 부하증가를 처리할 수 있다.  

         \(3\) 결합도를 낮춘다. --&gt; 전체 서비스에 영향을 낮춘다.

     * 단점 :   

         \(1\) 외부 메시징 서버에 의존성이 생김
   * 선택 기준 :  
     * 병렬적으로 수행이 가능한 것은 비동기로... 
     * 잘 모르겠다면 먼저 동기로 개발 후 비동기로 전환하라
     * 비동기의 복잡성을 줄이려면 리액티브 프로그래밍\(? --&gt; client 인가..\)이 좋다 
3. 마이크로서비스 오케스트레이션
   * 방식  
     1. ESB\(Saas\), 여러개의 서비스를 모아 하나의 완전한 기능을 담당, 오케스트레이터가 중앙의 두뇌 역할
     2. Producer-Consumer 독립적으로 수행  
   * 마잍크로서비스 하나에 얼마나 많은 종단점\(Peer\)을 둘 것 인가?  
     1. 종단점은 중요하지 않다. 비지니스에 적합하게 적절하게 설계하는 것이 더욱 중요  

        X. [CQRS](https://docs.microsoft.com/ko-kr/azure/architecture/patterns/cqrs)
   * 가상머신 하나당 하나의 마이크로 서비스 또는 다수의 마이크로 서비스?
4. Rule Engine ???????
   * 방법
     1. 서비스 내부에 Code로 Rule 적용 - 단순하고, 서비스내에서만 사용될 경우 
     2. 서비스 내부에 내장된 룰 엔진 - 복잡하고, Service Context에 국한, 사용자와 관련이 없다.
     3. 외부의 중앙 저장소와 시스템 내부에 내장된 엔진을 이용 - Rule이 비지니스에 작성되고 관리, 복잡, 외부에서도 재사용 ex&gt; 권한?
5. BPM 의 역할과 작업 흐름 
   * 전 구간의 비즈니스 프로세스를 제어한다. 
   * 프로세스를 모니터링하는 도구로 이용.
6. 마이크로 서비스가 데이터 스토어를 공유할 수 있는가?
   * 독립가 원칙 - 최소한 스키마 수준의 분리만으로도 시작
   * 공유 데이터베이스가 필요한 경우 - 별도 마이크로 서비스로 분리해서 유연성을 확보하라 
7. Transaction 경계 설정 
   * Local Transaction을 이용할 것 
   * 분산된 Global Transaction은 피할 것 - 트랜젝션 경계가 두개의 서로 다른 마이크로 서비스로 학장되지 않도록 
   * 용어 : [2단계 커밋](https://www.joinc.co.kr/w/man/12/TwoPhaseCommit),\[분산 Transaction\]

     \([https://ko.wikipedia.org/wiki/분산\_트랜잭션](https://ko.wikipedia.org/wiki/분산_트랜잭션)\)

   * 방안 
     1. Transaction 요구 사항을 단순화 하기 위한 사용 사례의 변경 \(상태를 만들거나 프로세스를 변경\)
     2. 분산 Transaction 시나리오 
8. 서비스 종단점 설계 고려 사항
   * 설계 
     1. 계약 설계 : 소비자 중심 계약, 포스텔의 법칙 
     2. 프로토콜 선택 : 메시지 지향 서비스 , 최적화된 통신 프로토콜 
9. 공유 라이브러리 처리 
   * Dry 원칙 :  모든 지식은 하나의 시스템 안에서 오직 하나의 모호하지 않은, 권위를 가진 표현으로 존재해야한다. 
   * 코드 내장 방식 
     1. 버그 픽스나 개선 사항이 있을때 모두 반영해야한다.
   * 별도의 마이크로 서비스
10. 마이크로서비스에서의 사용자 인터페이스 
    * 개별 제품으로서 존재를 원칙으로 한다.
    * \[MashUp\]\([https://ko.wikipedia.org/wiki/매시업\_\(웹\_개발](https://ko.wikipedia.org/wiki/매시업_%28웹_개발)\)\)
11. 마이크로서비스에서 API 게이트 웨이의 사용 
    * Restful 서비스 노출하는 방식으로 개발의 문제점   
      1. 계약에 대한 기대 사항의 불일치
      2. 페이지 렌더링을 위해 서버에 많은 요청
    * 해결방안 
      1. HATEOAS
      2. Client가 요청시 필요한 필드를 지정해서 요청을 보내는 방식 - 필터링 하는 서버측 로직이 복잡해짐
      3. 간접화 개념을 사용한다. - GateWay가 데이터 소비자의 명세에 따라 데이터를 변환한다.   
         1. Gateway를 개별 서비스에 둘 수 도 있다. 유형에 따른 세부적 제어와 복잡한 데이터 변환이 필요한 경우에 적합  
         2. 공용으로 하나의 게이트웨이를 둘 수 도 있다. 
12. ESB 및 iPass와 마이크로서비스의 사용 
    * MSA에서의 ESB의 기능 ..
      1. API Gateway 로 대체 가능 - 메세지 중제 , 오케스트레이션 역할 
      2. 어텝터 기능은 서비스가 구체적 구현체를 제공하기에 불필요 
13. 서비스 버져닝 고려사항
    * Semantic Versioning이 대표적 
      1. Major: API 호환이 안되는 대규모 변경
      2. Minor: 하위 호환을 유지하는 한도 내에서의 변경
      3. patch: 하위 호환을 유지하는 버그 수정 
    * Versioning은 단위 기능 보다는 서비스 버전을 변경하는 방법이 더 관리하기 편하다.
    * Rest Versioning
      1. URI Versioning
      2. MideaType Versioning
      3. 커스텀 해더 
14. CORS 설계 
    * ALL OR GateWay 
15. 공유 참조 데이터 처리 
    * 각 서비스에서 하드코드로 집어 넣음
    * 별도의 마이크로 서비스로 빼는 방법 
    * 데이터를 모든 마이크로 서비스에서 복제 
    * 필요한 데이터를 로컬에 캐시해서 
16. 마이크로서비스와 대규모 데이터 작업 
    1. 데이터가 생성될 때 사전 집계 - 데이터 중복의 위험
    2. Batch를 이용하는 방법 

