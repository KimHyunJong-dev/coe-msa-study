# summary

## 1. Introduction

#### IT 운영 조직의 3대 관심사

* 장애
* 성능 저하 : 대체로 자원을 최적화하는 방식으로 문제를 해결하지만, 어느 순간부터 scale-up 한계에 부딪히게 된다.
* 변경 지연 : 시스템이 복잡해 질수록 비즈니스 변경에 따른 변경 대응이 늦어진다. 

-&gt; 세 가지 핵심 이슈를 해결하기 위한 활동이 활발할 수록 시스템 **복잡도 증가**

-&gt; 낮은 복잡도록 유지하도록 설계하여 문제에 대한 신속한 대응 역량 제공

ex\) 거대한 규모의 시스템의 경우 한 줄이라도 변경하면 전체를 재배포해야 되고 배포 시간이 오래 걸림

#### 모델링 기술의 흐름

* SW 설계 접근방법 : 절차 지향 설계 vs 객체 지향 기반 설계 
* 객체 지향 설계 이후, SW 설계는 비약적으로 성장함 \(OOAD -&gt; CBD -&gt; SOA -&gt; MSA\)
* CBD는 업무를 담을 모듈을 설계할 때 컴포넌트 단위로 설계하려는 접근 방법
* SOA와 MSA는 컴포넌트를 배포하고 제공할 때 어떤 구조로 할 것인가를 결정하는 접근 방법

```text
OOAD : 객체 하나로 표현하기 불가
-> CBD : component는 객체 모음. 고객과 사용하는 언어가 같아짐.
         component는 내부에서 밖에 도달 못함. (remote 이슈. 내부통신만 가능) 대칭적인 플랫폼간 통신밖에 못함
-> SOA : WebService(remote에 접근하기 위한 표준을 만들려고 했음. 너무 무겁고 느려. 클라이트 모듈이 필요해 -> 비용)
-> MSA : RESTful. HTTP(CRUD로 접근). Smart client, Dumb pipe
```

#### Why MSA?

국내 대부분 시스템은 무늬만 컴포넌트에 일체식 배포 구조

* 무늬만 컴포넌트
  * 주요 업무를 SQL로 표현
  * 변경이 어려운 데이터 모델 기반
  * 느슨한 결합 원칙 위배
  * 변경 영향도 매우 큼
  * 변경 요청 대응이 느림
  * 지속적인 복잡도 증가
* 일체식 구조
  * 통합 빌드/배포
  * 개별 Scale-out 불가능
  * 대용량 서버 필요
  * 상대적으로 낮은 성능
  * 하나의 오류로 전체 실패 발생
  * 실패 대응 구조

컴포넌트 방식의 시스템 구성은 SQL문과 DB모델에 놓인 업무로직을 컴포넌트로 잘 나누어 배치.

MSA는 업무 로직을 마이크로 서비스화 하고, 데이터 저장소를 서비스 단위로 분리하여 배치

-&gt; 업무 단위 독립성 확보, 개별 업데이트 배포, Scale-out 가능, 언제든 클라우드로 이전 가능

```text
마이크로서비스는 어느 날 하늘에서 떨어진 기술이 아닙니다.
과거의 기술이 축적되고 과거의 경험이 정제된 후, 
클라우드 환경을 만나 드디어 꽃을 피우는 기술입니다.
```

## 2. MSA 기반 기술 흐름

### MSA란?

#### MSA 전제 조건

```text
- DB로부터 자유로워지기
- 잘 구성된 내부구조
- API에 대한 관점 (메세지 기반)
```

#### MAS 구성 \(명확한 Role 필수\)

* Infra Arch\(쿠버네티스 등을 아는 사람 for 배포\)
* CI/CD Engineer
* Software Arch\(선택의 영역\)
* MSA 개발자

#### 시스템이 MSA인가를 판단하는 기준

```text
DB를 바꾼다고 했을 때 반응으로 확인할 수 있다. DB를 쉽게 변경할 수 있는 구조라면 MSA!
관계형 DB라는 전제를 깔고가면 안되고 트랜젝션(롤백)으로 비즈니스를 처리하려고 하면 안 된다.
만약에 프로세스가 문제면 트랜젝션이 아니라 보상 매커니즘이 작동해서 풀어야 한다.
보통 시스템에서 DB CPU가 Full이고 WAS는 놀고있는 경우가 많은데 기존 벤더사의 RDB는 Scale-Up의 한계가 있고 비용이 매우 크다.
UI, DB의 로직은 모두 Sale-Out이 가능한 WAS로 옮겨야 한다.
```

#### 저장소의 역할 변화

RDB는 트랜잭션을 통해 Atomicity, Consistency, Integraty를 관리해주는 "관리 시스템" \(ACID 트랜잭션 기반\)

NoSQL은 Store로 "저장소"일 뿐 주요 기능은 로직에서 처리해야 함 \(BASE 트랜잭션 기반\)

RDB는 트랜잭션 처리 중 자원 차단을 통해 일치성\(Consistency\)에 초점을 두지만,

NoSQL은 가용성\(Availability\)에 초점을 둠.

**DB로부터 관심사 분리**

```text
DB는 단지 Store일 뿐.
MSA는 NoSQL을 전제로 하는데
우리는 지금까지 복잡한 쿼리에 로직을 담고 시스템의 핵심이라고 여겨왔다.
결국 RDB를 버리지 못 해 MSA를 받아들이는데 거부감을 가지게 된다.
데이터를 Store에서 불러와 모든 로직은 코딩으로 풀어야 함.
```

**통합은 SW 용어가 아니다**

```text
통합은 벤더사의 Scale-up 수익을 내기 위한 마케팅 용어일 뿐 SW용어가 아님.
Dependency를 낮추는 방향으로 가야함. loose coupled
```

#### 이벤트 기반으로의 변화

* 트랜젝션으로 관리하는게 아니라 모든 건 이벤트로 던진다.

  ex\) Walking , Review  -&gt; 서비스 간 통신하지 않고 Queue로 던짐

* batch로 하지 말고 메세지 기반으로 -&gt; batch 없어짐

### 참고

**Akka Actor 기반 \(MSA가 추구하는 이상적인 결과\)**

**lagom \(MSA가 지향하는 설계 셋\)**

[https://www.lagomframework.com/](https://www.lagomframework.com/)

**Kafka vs rabbitmq**

```text
rabbitmq는 only broker. start -> end 전송에 대한 것만 시간이 얼마나 걸리든 guarantee함 . 실시간과 replication(되긴 하지만 초기 설계 시작은 아님) X
   -> kafka는 stream 처리에 + broker (실시간 처리해야하니까 replication & distributed 가능하도록)
   -> stream 처리는 pipeline에서. topic은 변경되지 않지만. 다른 topic으로 전달되고 -> 전달되고의 일련의 과정을 가짐
   -> review를 pipeline에 넣었을때, pipeline내에서 각각의 lib를 거쳐 결과는 여러가지 topic으로 나올 수 있음 
   -> why kafka? 내가 브로커만 사용하더라도 kafka를 사용하는게 맞다. 왜냐면 항상 실시간 처리에 대한 요구가 있으니까.
```

